#Использовать fs
#Использовать 1commands
#Использовать tempfiles
<<<<<<< HEAD

Перем Лог;
=======
#Использовать json

Перем Лог;
Перем ПарсерJSON;

Перем РабочаяОбласть;
Перем СписокПапокСПроектами;
Перем СписокИменПроектов;
Перем КаталогОтчетов;
Перем ИмяФайлаРезультата;
Перем УдалятьФайлРезультата;
Перем ИмяПредыдущегоФайлаРезультата;
Перем ИсключенияВОшибках;
Перем ПропускиВОшибках;
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82

///////////////////////////////////////////////////////////////////////////////////////////////////
// Прикладной интерфейс

Процедура ЗарегистрироватьКоманду(Знач ИмяКоманды, Знач Парсер) Экспорт
	
	ОписаниеКоманды = Парсер.ОписаниеКоманды(ИмяКоманды, "Проверка проекта EDT");
<<<<<<< HEAD
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--junitpath", "Путь отчета в формате JUnit.xml");
	Парсер.ДобавитьПараметрФлагКоманды(ОписаниеКоманды, "--groupbymetadata",
	"Группировать проверки в junit по метаданным конфигурации");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--exception-file",
	"Путь файла с указанием пропускаемых исключений
	|	Формат файла: в каждой строке файла указан текст пропускаемого исключения или его часть
	|	Кодировка: UTF-8");
=======
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--allure-results",
	"Путь к каталогу результатов Allure");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--exception-file",
	"Путь файла с указанием пропускаемых ошибок
	|	Формат файла: в каждой строке файла указан текст пропускаемого исключения или его часть
	|	Кодировка: UTF-8");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--validation-result",
	"Необязательный аргумент. Путь к файлу, в который будут записаны результаты проверки проекта.");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--prev-validation-result",
	"Необязательный аргумент. Путь к файлу с предыдущими результатами проверки проекта.
	|	Если заполнен, то результат будет записан как разность новых ошибок и старых.
	|	Ошибки и предупреждения, которые есть в предыдущем файле, но которых нет в новом - будут помечены как passed (Исправлено).
	|	Ошибки и предупреждения, которые есть только в новом файле результатов - будут помечены как failed (Ошибки) и broken (Предупреждения).
	|	Все остальные ошибки и предупреждения, которые есть в обоих файлах, будут помечены как skipped (Пропущено).");
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--workspace-location", "Расположение рабочей области");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--project-list", 
	"Необязательный аргумент. Список папок, откуда загрузить проекты в формате EDT для проверки.
	|	Одновременно можно использовать только один агрумент: project-list или project-name-list");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--project-name-list",
	"Необязательный аргумент. Cписок имен проектов в текущей рабочей области, откуда загрузить проекты в формате EDT для проверки.
	|	Одновременно можно использовать только один агрумент: project-list или project-name-list.
	|
	|	Пример выполнения:
	|		vanessa-runner edt-validate --project-list D:/project-1 D:/project-2 --workspace-location D:/workspace
	|
	|	ВНИМАНИЕ! Параметры, которые перечислены далее, не используются.
	|
	|");
	
	Парсер.ДобавитьКоманду(ОписаниеКоманды);
	
КонецПроцедуры

// Выполняет логику команды
// 
// Параметры:
//   ПараметрыКоманды - Соответствие - Соответствие ключей командной строки и их значений
//   ДополнительныеПараметры - Соответствие -  (необязательно) дополнительные параметры
//
Функция ВыполнитьКоманду(Знач ПараметрыКоманды, Знач ДополнительныеПараметры = Неопределено) Экспорт
	
	Лог = ДополнительныеПараметры.Лог;
<<<<<<< HEAD
	// Лог.УстановитьУровень(УровниЛога.Отладка);
	
	ПутьОтчетаВФорматеJUnitxml = ПараметрыКоманды["--junitpath"];
	Если ПутьОтчетаВФорматеJUnitxml = Неопределено Тогда
		ПутьОтчетаВФорматеJUnitxml = "";
=======
	
	ПрочитатьПараметры( ПараметрыКоманды );
	
	Если ЗначениеЗаполнено( ИмяПредыдущегоФайлаРезультата ) Тогда
		
		тзРезультатПред = ПрочитатьТаблицуИзФайлаРезультата(ИмяПредыдущегоФайлаРезультата);
		
	КонецЕсли;
	
	Успешно = ВыполнитьПроверкуEDT();
	
	тзРезультат = ПрочитатьТаблицуИзФайлаРезультата( ИмяФайлаРезультата );
	
	УдалитьФайлРезультатовПриНеобходимости();
	
	Если ЗначениеЗаполнено( ИмяПредыдущегоФайлаРезультата ) Тогда
		
		тзРезультат = РазностнаяТаблицаРезультатов( тзРезультатПред, тзРезультат );
		
	КонецЕсли;
	
	СоздатьФайлыПоТаблицеПроверки(тзРезультат);
	
	РезультатыКоманд = МенеджерКомандПриложения.РезультатыКоманд();
	
	Возврат ?(Успешно, РезультатыКоманд.Успех, РезультатыКоманд.ОшибкаВремениВыполнения);
	
КонецФункции

// { приватная часть 

Процедура ПрочитатьПараметры( Знач ПараметрыКоманды )
	
	Лог.Отладка("Чтение параметров");

	КаталогОтчетов = ПараметрыКоманды["--allure-results"];

	Если КаталогОтчетов = Неопределено Тогда

		КаталогОтчетов = "";
		Лог.Отладка("	Каталог отчетов (--allure-results) не задан.");

	Иначе

		Лог.Отладка("	Каталог отчетов (--allure-results): %1", КаталогОтчетов);

>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	КонецЕсли;
	
	РабочаяОбласть = ПараметрыКоманды["--workspace-location"];
	СписокПапокСПроектами = ПараметрыКоманды["--project-list"];
	СписокИменПроектов = ПараметрыКоманды["--project-name-list"];
	
<<<<<<< HEAD
	ИмяФайлаИсключенийОшибок = ПараметрыКоманды["--exception-file"];
	ГруппироватьПоМетаданным = ПараметрыКоманды["--groupbymetadata"];
	
	ДатаНачала = ТекущаяДата();
	
	ИмяФайлаРезультата = ПолучитьИмяВременногоФайла("out");
	
	Попытка
		
		Команда = Новый Команда;
		Команда.УстановитьКоманду( "ring edt workspace validate");
		Команда.УстановитьКодировкуВывода(КодировкаТекста.UTF8);
		Команда.ДобавитьПараметр( "--workspace-location " + РабочаяОбласть );
		Команда.ДобавитьПараметр( "--file " + ИмяФайлаРезультата );
		
		Если ЗначениеЗаполнено( СписокПапокСПроектами ) Тогда
			Команда.ДобавитьПараметр("--project-list " + СписокПапокСПроектами );
		КонецЕсли;
		
		Если ЗначениеЗаполнено( СписокИменПроектов ) Тогда
			Команда.ДобавитьПараметр("--project-name-list " + СписокИменПроектов );
		КонецЕсли;
		
		Команда.УстановитьИсполнениеЧерезКомандыСистемы(Ложь);
		Команда.ПоказыватьВыводНемедленно(Ложь);
		КодВозврата = Команда.Исполнить();
		
	Исключение
		УдалитьФайлы(ИмяФайлаРезультата);
		ВызватьИсключение ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Успешно = КодВозврата = 0;

	тзРезультат = ПрочитатьТаблицуИзФайлаРезультата( ИмяФайлаРезультата );

	УдалитьФайлы(ИмяФайлаРезультата);
	
	Если ЗначениеЗаполнено(ПутьОтчетаВФорматеJUnitxml) Тогда
		
		Лог.Отладка("Путь к лог-файлу проверки %1", ПутьОтчетаВФорматеJUnitxml);
		
		ФайлОтчетаВФорматеJUnitxml = Новый Файл(ОбъединитьПути(ТекущийКаталог(), ПутьОтчетаВФорматеJUnitxml));
		Лог.Отладка("Полный путь к лог-файлу проверки %1", ФайлОтчетаВФорматеJUnitxml.ПолноеИмя);
		Лог.Отладка("Каталог лог-файла проверки %1", ФайлОтчетаВФорматеJUnitxml.Путь);
		ФС.ОбеспечитьКаталог(ФайлОтчетаВФорматеJUnitxml.Путь);
		УдалитьФайлы(ФайлОтчетаВФорматеJUnitxml.ПолноеИмя);
		
		ВывестиОтчетПроверкиКонфигурацииВФорматеJUnitXML(ПутьОтчетаВФорматеJUnitxml, тзРезультат, 
			Успешно, ДатаНачала, ГруппироватьПоМетаданным, ИмяФайлаИсключенийОшибок);
		
		Лог.Информация("Сформированы результаты проверки в формате JUnit.xml - %1", ПутьОтчетаВФорматеJUnitxml);
		
	КонецЕсли;
	
	РезультатыКоманд = МенеджерКомандПриложения.РезультатыКоманд();

	Возврат ?(Успешно, РезультатыКоманд.Успех, РезультатыКоманд.ОшибкаВремениВыполнения);
	
КонецФункции

// { приватная часть 


Функция ПрочитатьТаблицуИзФайлаРезультата( Знач пПутьКФайлу )
	
	Лог.Отладка("Путь к файлу-результату проверки %1", пПутьКФайлу);

=======
	Лог.Отладка("	Рабочая область (--workspace-location): %1", Строка( РабочаяОбласть ));
	Лог.Отладка("	Список папок с проектами (--project-list): %1", Строка( СписокПапокСПроектами ));
	Лог.Отладка("	Список имен проектов (--project-name-list): %1", Строка( СписокИменПроектов ));

	ИмяФайлаРезультата = ПараметрыКоманды["--validation-result"];
	УдалятьФайлРезультата = Ложь;

	Если ИмяФайлаРезультата = Неопределено Тогда

		ИмяФайлаРезультата = ПолучитьИмяВременногоФайла("out");
		УдалятьФайлРезультата = Истина;
		Лог.Отладка("	Файл результата не задан (--validation-result). Будет использован временный файл.");

	КонецЕсли;

	Лог.Отладка("	Файл результата (--validation-result): %1", ИмяФайлаРезультата);
	
	ИмяПредыдущегоФайлаРезультата = ПараметрыКоманды["--prev-validation-result"];

	Лог.Отладка("	Файл предыдущего результата (--prev-validation-result): %1", Строка( ИмяПредыдущегоФайлаРезультата ));
	
	ИсключенияВОшибках = ИсключаемыеОшибки();
	ПропускиВОшибках = СодержимоеФайлаПропускаемыхОшибок( ПараметрыКоманды["--exception-file"] );

	ПарсерJSON  = Новый ПарсерJSON();
	
КонецПроцедуры

Функция ВыполнитьПроверкуEDT()
	
	Если Не ЗначениеЗаполнено( РабочаяОбласть ) Тогда
		
		Лог.Информация("Рабочая область (--workspace-location) не указана. Проверка проекта пропущена.");
		
		Возврат Истина;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено( СписокПапокСПроектами ) 
		И Не ЗначениеЗаполнено( СписокИменПроектов ) Тогда
		
		Лог.Информация("Проекты к проверке (--project-list или project-name-list) не указаны. Проверка проекта пропущена.");
		
		Возврат Истина;
		
	КонецЕсли;
	
	Попытка

		// Для EDT критично, чтобы файла не существовало
		ОбщиеМетоды.УдалитьФайлЕслиОнСуществует(ИмяФайлаРезультата);
		
		Команда = Новый Команда;
		Команда.УстановитьСтрокуЗапуска( "ring edt workspace validate" );
		Команда.УстановитьКодировкуВывода(КодировкаТекста.ANSI);
		Команда.ДобавитьПараметр( "--workspace-location " + ОбщиеМетоды.ОбернутьПутьВКавычки( РабочаяОбласть ) );
		Команда.ДобавитьПараметр( "--file " + ОбщиеМетоды.ОбернутьПутьВКавычки( ИмяФайлаРезультата ) );
		
		Если ЗначениеЗаполнено( СписокПапокСПроектами ) Тогда
			Команда.ДобавитьПараметр("--project-list " + ОбщиеМетоды.ОбернутьПутьВКавычки( СписокПапокСПроектами ) );
		КонецЕсли;
		
		Если ЗначениеЗаполнено( СписокИменПроектов ) Тогда
			Команда.ДобавитьПараметр("--project-name-list " + ОбщиеМетоды.ОбернутьПутьВКавычки( СписокИменПроектов ) );
		КонецЕсли;
		
		Лог.Информация("Начало проверки EDT-проекта");
		началоЗамера = ТекущаяДата();
		
		КодВозврата = Команда.Исполнить();
		
		Лог.Информация( "Проверка EDT-проекта завершена за %1с", Окр( ТекущаяДата()-  началоЗамера ));
		
	Исключение
		
		УдалитьФайлРезультатовПриНеобходимости();
		ВызватьИсключение ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Возврат КодВозврата = 0;
	
КонецФункции

Процедура УдалитьФайлРезультатовПриНеобходимости()
	
	Если УдалятьФайлРезультата Тогда
		
		ОбщиеМетоды.УдалитьФайлЕслиОнСуществует(ИмяФайлаРезультата);
		
	КонецЕсли;
	
КонецПроцедуры

Функция СодержимоеФайлаПропускаемыхОшибок(Знач ИмяФайлаПропускаемыхОшибок)
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(ИмяФайлаПропускаемыхОшибок) Тогда
		Лог.Информация( "Файл пропускаемых ошибок (--exception-file) не указан. Пропуски не используются." );
		Возврат Результат;
	КонецЕсли;
	
	Лог.Отладка("Чтение файла пропускаемых ошибок из %1", ИмяФайлаПропускаемыхОшибок);
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаПропускаемыхОшибок, КодировкаТекста.UTF8);
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	Пока ПрочитаннаяСтрока <> Неопределено Цикл
		Если Не ПустаяСтрока(ПрочитаннаяСтрока) Тогда
			пропуск = СокрЛП(НРег(ПрочитаннаяСтрока));
			Результат.Добавить(пропуск);
			Лог.Отладка("Добавлено в пропуски: %1", пропуск);
		КонецЕсли;
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	КонецЦикла;
	
	Лог.Отладка("Прочитано пропусков: %1", Результат.Количество());	
	
	Возврат Результат;
	
КонецФункции

Функция ИсключаемыеОшибки()
	
	// Определяем строки для исключения из ошибок 
	// См. стандарт "Обработчики событий модуля формы, подключаемые из кода"
	// https://its.1c.ru/db/v8std#content:-2145783155:hdoc
	МассивСтрокИсключений = Новый Массив();
	МассивСтрокИсключений.Добавить(Нрег("Неиспользуемый метод ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("Пустой обработчик: ""Подключаемый_"));
	
	Возврат МассивСтрокИсключений;
	
КонецФункции


// Создание таблицы результата
Функция ПрочитатьТаблицуИзФайлаРезультата( Знач пПутьКФайлу )
	
	Лог.Отладка("Чтение файла результата %1", пПутьКФайлу);
	
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить( "ДатаОбнаружения" );
	тз.Колонки.Добавить( "Тип" );
	тз.Колонки.Добавить( "Проект" );
	тз.Колонки.Добавить( "Метаданные" );
	тз.Колонки.Добавить( "Положение" );
	тз.Колонки.Добавить( "Описание" );
	
<<<<<<< HEAD
	ЧтениеТекста = Новый ЧтениеТекста( пПутьКФайлу , КодировкаТекста.UTF8);
=======
	ЧтениеТекста = Новый ЧтениеТекста( пПутьКФайлу, КодировкаТекста.UTF8 );
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	
	Пока Не ПрочитаннаяСтрока = Неопределено Цикл
		
<<<<<<< HEAD
		Если ПустаяСтрока(ПрочитаннаяСтрока) Тогда
=======
		Если ПустаяСтрока( ПрочитаннаяСтрока ) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если СтрокаВходитВМассив( ПрочитаннаяСтрока, ИсключенияВОшибках ) Тогда
			ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
			Продолжить;
		КонецЕсли;
		
		компонентыСтроки = СтрРазделить( ПрочитаннаяСтрока, "	" );
		
		новСтрока = тз.Добавить();
		
		Для ц = 0 По 4 Цикл
			
			новСтрока[ц] = компонентыСтроки[ц];
			
		КонецЦикла;
		
		// В описании могут быть и табы, по которым делим
		
		Для ц = 5 По компонентыСтроки.ВГраница() Цикл
			
			Если ЗначениеЗаполнено( новСтрока.Описание ) Тогда
<<<<<<< HEAD
				новСтрока.Описание = новСтрока.Описание + "	";
			Иначе
				новСтрока.Описание = "";
=======
				
				новСтрока.Описание = новСтрока.Описание + "	";
				
			Иначе
				
				новСтрока.Описание = "";
				
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
			КонецЕсли;
			
			новСтрока.Описание = новСтрока.Описание + компонентыСтроки[ц];
			
		КонецЦикла;
		
<<<<<<< HEAD
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
		
	КонецЦикла;

	Лог.Отладка("Из файла-результата прочитано %1 строк", тз.Количество());

	Возврат тз;
	
КонецФункции

Процедура ВывестиОтчетПроверкиКонфигурацииВФорматеJUnitXML(Знач ПутьОтчетаВФорматеJUnitxml, 
	Знач тзРезультат, Знач НетОшибок, Знач ДатаНачала, Знач ГруппироватьПоМетаданным = Ложь,
	Знач ИмяФайлаИсключенийОшибок = Неопределено)
	
	ПредставлениеНабораТестов = ПредставлениеНабораТестов(ПутьОтчетаВФорматеJUnitxml);
	
	ИсключенияОшибок = СодержимоеФайлаИсключенийОшибок(ИмяФайлаИсключенийОшибок);
	
	Лог.Отладка("НетОшибок <%1>", НетОшибок);
	Если НетОшибок Тогда
		
		ЗаписьXML = НачатьЗаписьОтчета(ПредставлениеНабораТестов, 0, 0, ДатаНачала);
		ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase
		
	Иначе
		
		ТестовыеСлучаи = СтруктурироватьЛог(тзРезультат, ГруппироватьПоМетаданным, ИсключенияОшибок);
		
		ЗаписьXML = НачатьЗаписьОтчета(
		ПредставлениеНабораТестов,
		ТестовыеСлучаи.Ошибки.Количество(),
		ТестовыеСлучаи.Предупреждения.Количество(),
		ТестовыеСлучаи.Пропуски.Количество(),
		ДатаНачала);
		
		// Если есть ошибки, добавим в отчет текст всех ошибок без группировки
		Если ТестовыеСлучаи.Ошибки.Количество() > 0 Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента("failure");
			ЗаписьXML.ЗаписатьАтрибут("message", XMLСтрока(ЛогПроверкиИзКонфигуратора));
			ЗаписьXML.ЗаписатьКонецЭлемента(); // failure
		КонецЕсли;
		
		ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase summary
		
		Для Каждого ТекТестовыйСлучай Из ТестовыеСлучаи.Ошибки Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
			ЗаписьXML.ЗаписатьАтрибут("classname", СтрШаблон("%1.Ошибки", XMLСтрока(ПредставлениеНабораТестов)));
			ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(ТекТестовыйСлучай.Ключ));
			ЗаписьXML.ЗаписатьАтрибут("status", "failure");
			
			ЗаписьXML.ЗаписатьНачалоЭлемента("failure");
			ЗаписьXML.ЗаписатьАтрибут("message", XMLСтрока(ТекТестовыйСлучай.Значение));
			ЗаписьXML.ЗаписатьКонецЭлемента(); // failure
			
			ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase errors	
		КонецЦикла;
		
		Для Каждого ТекТестовыйСлучай Из ТестовыеСлучаи.Пропуски Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
			ЗаписьXML.ЗаписатьАтрибут("classname", СтрШаблон("%1.Пропуски", XMLСтрока(ПредставлениеНабораТестов)));
			ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(ТекТестовыйСлучай.Ключ));
			ЗаписьXML.ЗаписатьАтрибут("status", "skipped");
			ЗаписьXML.ЗаписатьНачалоЭлемента("skipped");
			ЗаписьXML.ЗаписатьКонецЭлемента(); // skipped
			ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase
		КонецЦикла;
		
	КонецЕсли;
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); // testsuite
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); // testsuites
	
	СтрокаХМЛ = ЗаписьXML.Закрыть();
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ПутьОтчетаВФорматеJUnitxml);
	ЗаписьXML.ЗаписатьБезОбработки(СтрокаХМЛ);// таким образом файл будет записан всего один раз, и не будет проблем с обработкой на билд-сервере TeamCity
	ЗаписьXML.Закрыть();
	
	Лог.Отладка("СтрокаХМЛ %1", СтрокаХМЛ);
	
КонецПроцедуры

Функция ПредставлениеНабораТестов(Знач ПутьОтчетаВФорматеJUnitxml)
	
	Если Не ЗначениеЗаполнено(ПутьОтчетаВФорматеJUnitxml) Тогда
		Возврат "CheckConfig";
	КонецЕсли;
	
	Файл = Новый Файл(ПутьОтчетаВФорматеJUnitxml);
	Возврат СтрШаблон("CheckConfig.%1", Файл.ИмяБезРасширения);
	
КонецФункции

Функция СодержимоеФайлаИсключенийОшибок(Знач ИмяФайлаИсключенийОшибок)
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(ИмяФайлаИсключенийОшибок) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Лог.Отладка("Чтение файла исключений ошибок из %1", ИмяФайлаИсключенийОшибок);
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаИсключенийОшибок, КодировкаТекста.UTF8);
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	Пока ПрочитаннаяСтрока <> Неопределено Цикл
		Если Не ПустаяСтрока(ПрочитаннаяСтрока) Тогда
			ДобавляемоеИсключение = НормализованныйТекстОшибки(ПрочитаннаяСтрока);
			Результат.Добавить(ДобавляемоеИсключение);
			Лог.Отладка("Добавлено в исключения: %1", ДобавляемоеИсключение);
		КонецЕсли;
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	КонецЦикла;
	
	Лог.Отладка("Прочитано исключений: %1", Результат.Количество());	
	
	Возврат Результат;
	
КонецФункции

Функция НормализованныйТекстОшибки(Знач ТекстОшибки)
	
	Возврат СокрЛП(НРег(ТекстОшибки));
	
КонецФункции

Функция НачатьЗаписьОтчета(Знач ПредставлениеНабораТестов, Знач КоличествоОшибок, Знач КоличествоПропусков,
	Знач ДатаНачала)
	
	Лог.Отладка("ПредставлениеНабораТестов <%1>", ПредставлениеНабораТестов);
	Лог.Отладка("КоличествоОшибок <%1>", КоличествоОшибок);
	Лог.Отладка("КоличествоПропусков <%1>", КоличествоПропусков);
	
	Результат = Новый ЗаписьXML;
	Результат.УстановитьСтроку("UTF-8");
	Результат.ЗаписатьОбъявлениеXML();
	
	ВремяВыполнения = ТекущаяДата() - ДатаНачала;
	
	Результат.ЗаписатьНачалоЭлемента("testsuites");
	Результат.ЗаписатьАтрибут("name", XMLСтрока(ПредставлениеНабораТестов)); 
	
	КоличествоТестов = КоличествоОшибок + КоличествоПропусков;
	Если КоличествоТестов = 0 Тогда
		КоличествоТестов = 1;
	КонецЕсли;
	
	Результат.ЗаписатьАтрибут("tests", XMLСтрока(КоличествоТестов));
	Результат.ЗаписатьАтрибут("failures", XMLСтрока(КоличествоОшибок));
	Результат.ЗаписатьАтрибут("skipped", XMLСтрока(КоличествоПропусков));
	Результат.ЗаписатьАтрибут("time", XMLСтрока(ВремяВыполнения));
	
	Результат.ЗаписатьНачалоЭлемента("testsuite");
	Результат.ЗаписатьАтрибут("name", XMLСтрока(ПредставлениеНабораТестов));
	Результат.ЗаписатьНачалоЭлемента("properties");
	Результат.ЗаписатьКонецЭлемента(); // properties
	
	Результат.ЗаписатьНачалоЭлемента("testcase");
	Результат.ЗаписатьАтрибут("classname", XMLСтрока(ПредставлениеНабораТестов));
	Результат.ЗаписатьАтрибут("name", XMLСтрока("Все сообщения"));
	Результат.ЗаписатьАтрибут("time", XMLСтрока(ВремяВыполнения));
	Если КоличествоОшибок = 0 Тогда
		Результат.ЗаписатьАтрибут("status", "passed");	
	Иначе
		Результат.ЗаписатьАтрибут("status", "failure");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция СтруктурироватьЛог(Знач тзРезультат, Знач ГруппироватьПоМетаданным = Ложь, Знач ИсключенияОшибок = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("Ошибки", Новый Соответствие);
	Результат.Вставить("Предупреждения", Новый Соответствие);
	Результат.Вставить("Пропуски", Новый Соответствие); 
	
	ИмяТестСценарияПредыдущаяСтрока = "Синтаксическая проверка конфигурации";
	
	Если НЕ ГруппироватьПоМетаданным Тогда
		Результат.Ошибки.Вставить("Синтаксическая проверка конфигурации", XMLСтрока(ОбработанныйЛог));
		Возврат Результат;
	КонецЕсли;
	
	// Определяем строки для исключения из ошибок 
	// См. стандарт "Обработчики событий модуля формы, подключаемые из кода"
	// https://its.1c.ru/db/v8std#content:-2145783155:hdoc
	МассивСтрокИсключений = Новый Массив();
	МассивСтрокИсключений.Добавить(Нрег("Не обнаружено ссылок на процедуру: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("Не обнаружено ссылок на функцию: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("Пустой обработчик: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("No links to function found: ""Attachable_"));
	МассивСтрокИсключений.Добавить(Нрег("No links to procedure found: ""Attachable_"));
	МассивСтрокИсключений.Добавить(Нрег("Empty handler: ""Attachable_"));
	
	Для Каждого ТекСтрока Из тзРезультат Цикл
		
		Если ИсключитьСтроку(ТекСтрока, МассивСтрокИсключений) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТестСценария = ИмяТестСценария(ТекСтрока);
		
		Если ПустаяСтрока(ИмяТестСценария) Тогда
			ИмяТестСценария = ИмяТестСценарияПредыдущаяСтрока;
		КонецЕсли;
		
		ДополнитьРезультатТекстомОшибки(Результат, ТекСтрока, ИмяТестСценария, ИсключенияОшибок);
		
	КонецЦикла;
	
	Возврат Результат;
=======
		Если СтрокаВходитВМассив( ПрочитаннаяСтрока, ПропускиВОшибках ) Тогда
			
			новСтрока.Тип = ТипОшибки_Пропущено();
			
		КонецЕсли;
		
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
		
	КонецЦикла;
	
	ЧтениеТекста.Закрыть();

	Лог.Отладка("Из файла %1 прочитано %2 строк", пПутьКФайлу, тз.Количество());
	
	Возврат тз;
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	
КонецФункции

//Проверяет вхождение строк из массива в проверямой строке.
//Параметры:
//	ПроверяемаяСтрока - Строка - строка для проверки.
//	МассивСтрокИсключений - Массив - массив строк, для проверки. 
//
//Возвращаемое значение:
//	Булево - Истина, в проверяемой строке содежрится один из элементов массив.
//			 Ложь, не нашли
<<<<<<< HEAD
Функция ИсключитьСтроку(Знач ПроверяемаяСтрока, Знач МассивСтрокИсключений)
	Для каждого СтрИсключения Из МассивСтрокИсключений Цикл
		Если СтрНайти(Нрег(ПроверяемаяСтрока), СтрИсключения) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция ИмяТестСценария(Знач СтрокаЛога)
	
	Результат = "";
	
	ЧастиСтрокиЛога = СтрРазделить(СокрЛП(СтрокаЛога), " ", Ложь);
	Если ЗначениеЗаполнено(ЧастиСтрокиЛога) Тогда
		РезультатСтрока = ЧастиСтрокиЛога[0];
	КонецЕсли;
	
	Если СтрНачинаетсяС(РезультатСтрока, "{") Тогда
		
		РезультатСтрока = СтрЗаменить(РезультатСтрока, "{", "");
		РезультатСтрока = СтрЗаменить(РезультатСтрока, "}", "");
		ПозицияСкобки = СтрНайти(РезультатСтрока, "(");
		Если ПозицияСкобки > 1 Тогда
			Результат = Сред(РезультатСтрока, 1, ПозицияСкобки - 1);
		КонецЕсли;
	ИначеЕсли ЧастиСтрокиЛога.Количество() > 0 Тогда
		Результат = РезультатСтрока;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДополнитьРезультатТекстомОшибки(Знач Результат, Знач ТекСтрока, Знач ИмяТестСценария, Знач ИсключенияОшибок)
	
	Если СледуетПропуститьОшибку(ТекСтрока, ИсключенияОшибок) Тогда
		Раздел = "Пропуски";
	Иначе
		Раздел = "Ошибки";
	КонецЕсли;
	
	Если Результат[Раздел][ИмяТестСценария] = Неопределено Тогда
		Результат[Раздел][ИмяТестСценария] = СокрЛП(ТекСтрока);
	Иначе
		Результат[Раздел][ИмяТестСценария] = СтрШаблон(
		"%1
		|%2",
		Результат[Раздел][ИмяТестСценария],
		СокрЛП(ТекСтрока));
	КонецЕсли;
	
КонецПроцедуры

Функция СледуетПропуститьОшибку(Знач ТекстОшибки, Знач ИсключенияОшибок)
	
	Если Не ЗначениеЗаполнено(ИсключенияОшибок) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ТекИсключение Из ИсключенияОшибок Цикл
		Если СтрНайти(НормализованныйТекстОшибки(ТекстОшибки), ТекИсключение) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//////////////////////////////////
// Из обработки 
/////////////////////////////////

Процедура КнопкаВыполнитьНажатие( Кнопка )
	
	тз = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлуРезультата() );
	
	СоздатьФайлыПоТаблицеПроверки(тз);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыПостроитьРазностныйОтчет(Кнопка)
	
	тз_стар = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлу_СтарыйРезультат() );
	тз_стар.Колонки.Добавить("Изменение");
	тз_стар.ЗаполнитьЗначения(1, "Изменение" );
	
	тз = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлу_НовыйРезультат() );
=======
Функция СтрокаВходитВМассив( Знач ПроверяемаяСтрока, Знач МассивСтрокИсключений )
	
	Для каждого СтрИсключения Из МассивСтрокИсключений Цикл

		Если СтрНайти(Нрег(ПроверяемаяСтрока), СтрИсключения) > 0 Тогда

			Возврат Истина;

		КонецЕсли;

	КонецЦикла;

	Возврат Ложь;

КонецФункции

Функция РазностнаяТаблицаРезультатов( Знач пТЗ_пред, Знач пТЗ_нов )
	
	тз_стар = пТЗ_пред.Скопировать();
	тз_стар.Колонки.Добавить("Изменение");
	тз_стар.ЗаполнитьЗначения(1, "Изменение" );
	
	тз = пТЗ_нов.Скопировать();
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	тз.Колонки.Добавить("Изменение");
	тз.ЗаполнитьЗначения(-1, "Изменение" );
	
	Для каждого цСтрока Из тз_стар Цикл
		
		ЗаполнитьЗначенияСвойств( тз.Добавить(), цСтрока );
		
	КонецЦикла;
	
	тз.Свернуть( "Тип,Проект,Метаданные,Положение,Описание" , "Изменение" );
	
	Для каждого цСтрока Из тз Цикл
		
		Если цСтрока.Изменение = 0 Тогда
			
			// есть и в старой и в новой таблице
<<<<<<< HEAD
			цСтрока.Тип = "Пропущено";
=======
			цСтрока.Тип = ТипОшибки_Пропущено();
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
			
		ИначеЕсли цСтрока.Изменение > 0 Тогда
			
			// есть только в старой
<<<<<<< HEAD
			цСтрока.Тип = "Исправлено";
=======
			цСтрока.Тип = ТипОшибки_Исправлено();
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
			
		Иначе
			
			// Внесли новую ошибку
			
		КонецЕсли;
		
	КонецЦикла;
	
<<<<<<< HEAD
	СоздатьФайлыПоТаблицеПроверки(тз);
	
КонецПроцедуры

Функция ПрочитатьТаблицуИзФайлаРезультата( Знач пПутьКФайлу )
	
	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить( "ДатаОбнаружения" );
	тз.Колонки.Добавить( "Тип" );
	тз.Колонки.Добавить( "Проект" );
	тз.Колонки.Добавить( "Метаданные" );
	тз.Колонки.Добавить( "Положение" );
	тз.Колонки.Добавить( "Описание" );
	
	ЧтениеТекста = Новый ЧтениеТекста( пПутьКФайлу, КодировкаТекста.UTF8 );
	
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	
	Пока Не ПрочитаннаяСтрока = Неопределено Цикл
		
		Если ПустаяСтрока( ПрочитаннаяСтрока ) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		компонентыСтроки = СтрРазделить( ПрочитаннаяСтрока, "	" );
		
		новСтрока = тз.Добавить();
		
		Для ц = 0 По 4 Цикл
			
			новСтрока[ц] = компонентыСтроки[ц];
			
		КонецЦикла;
		
		// В описании могут быть и табы, по которым делим
		
		Для ц = 5 По компонентыСтроки.ВГраница() Цикл
			
			Если ЗначениеЗаполнено( новСтрока.Описание ) Тогда
				
				новСтрока.Описание = новСтрока.Описание + "	";
				
			Иначе
				
				новСтрока.Описание = "";
				
			КонецЕсли;
			
			новСтрока.Описание = новСтрока.Описание + компонентыСтроки[ц];
			
		КонецЦикла;
		
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
		
	КонецЦикла;
	
	Возврат тз;
	
КонецФункции

Процедура СоздатьФайлыПоТаблицеПроверки(Знач пТаблицаПроверки)
	
	УдалитьФайлы( ПапкаСОтчетомАллюр(), "*.json" );
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON( , Символы.Таб );
=======
	Возврат тз;
	
КонецФункции

Функция ТипОшибки_Пропущено()
	Возврат "Пропущено";
КонецФункции

Функция ТипОшибки_Исправлено()
	Возврат "Исправлено";
КонецФункции

// Создание файлов для отчета Allure

Процедура СоздатьФайлыПоТаблицеПроверки(Знач пТаблицаПроверки)
	
	Если Не ЗначениеЗаполнено( КаталогОтчетов ) Тогда
		
		Лог.Отладка("Каталог отчетов (--allure-results) не указан. Создание отчета Allure пропущено.");
		
		Возврат;
		
	КонецЕсли;
	
	началоЗамера = ТекущаяДата();
	
	Лог.Отладка("Создание файлов в каталоге %1.", КаталогОтчетов);
	Лог.Отладка("	Очистка каталога %1.", КаталогОтчетов);
	
	УдалитьФайлы( КаталогОтчетов, "*.json" );
	
	Лог.Отладка("	Создание файлов json по таблице проверки в каталоге %1.", КаталогОтчетов);
		
	количествоСозданныхФайлов = 0;
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	
	Для каждого цСтрока Из пТаблицаПроверки Цикл
		
		СтруктураВыгрузки           = ПолучитьОписаниеСценарияАллюр2();
		СтруктураВыгрузки.name      = цСтрока.Метаданные + ". " + цСтрока.Положение + ": " + цСтрока.Описание;
		СтруктураВыгрузки.fullName  = СтруктураВыгрузки.name;
		СтруктураВыгрузки.historyId = цСтрока.Метаданные + ". " + цСтрока.Положение + ": " + цСтрока.Описание;
		СтруктураВыгрузки.Вставить( "description", цСтрока.Описание );
		
		Если цСтрока.Тип = "Ошибка" Тогда
			
			СтруктураВыгрузки.status = "failed";
			
		ИначеЕсли цСтрока.Тип = "Предупреждение" Тогда
			
			СтруктураВыгрузки.status = "broken";
			
		ИначеЕсли цСтрока.Тип = "Пропущено" Тогда
			
			СтруктураВыгрузки.status = "skipped";
			
		ИначеЕсли цСтрока.Тип = "Исправлено" Тогда
			
			СтруктураВыгрузки.status = "passed";
			
		КонецЕсли;
		
		структ = Новый Структура( "name,value", "package", цСтрока.Метаданные );
		СтруктураВыгрузки.labels.Добавить( структ );
		
		Для каждого цКонтекст Из ПолучитьКонтексты( цСтрока.Описание ) Цикл
			
			структ = Новый Структура( "name,value", "tag", цКонтекст );
			СтруктураВыгрузки.labels.Добавить( структ );
			
		КонецЦикла;
		
		структ = Новый Структура( "name,value", "story", ОписаниеФункциональности( цСтрока.Описание ) );
		СтруктураВыгрузки.labels.Добавить( структ );
		
<<<<<<< HEAD
		РеальноеИмяФайла = ПапкаСОтчетомАллюр() + "" + СтруктураВыгрузки.uuid + "-result.json";
		
		ЗаписьJSON = Новый ЗаписьJSON;
		
		ЗаписьJSON.УстановитьСтроку( ПараметрыЗаписиJSON );
		ЗаписьJSON.ОткрытьФайл( РеальноеИмяФайла, , , ПараметрыЗаписиJSON );
		
		ЗаписатьJSON( ЗаписьJSON, СтруктураВыгрузки );
		ЗаписьJSON.Закрыть();
		
	КонецЦикла;
	
	СоздатьФайлКатегорий();

=======
		РеальноеИмяФайла = ОбъединитьПути( КаталогОтчетов, "" + СтруктураВыгрузки.uuid + "-result.json" );
		
		ЗаписатьФайлJSON( РеальноеИмяФайла, СтруктураВыгрузки);
		
		количествоСозданныхФайлов = количествоСозданныхФайлов + 1;
		
	КонецЦикла;
	
	лог.Отладка( "	Созданы файлы отчетов (%1) в каталоге %2 за %3с", количествоСозданныхФайлов, КаталогОтчетов, Окр( ТекущаяДата() - началоЗамера ));

	СоздатьФайлКатегорий();
	
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
КонецПроцедуры

Процедура СоздатьФайлКатегорий()
	
<<<<<<< HEAD
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON( , Символы.Таб );
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку( ПараметрыЗаписиJSON );
	ЗаписьJSON.ОткрытьФайл( ПапкаСОтчетомАллюр() + "categories.json", , , ПараметрыЗаписиJSON );
=======
	имяФайлаКатегорий = ОбъединитьПути( КаталогОтчетов, "categories.json" );
	
	Лог.Отладка("	Создание файла категорий %1.", имяФайлаКатегорий);
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	
	категории = Новый Массив;
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "failed" );
	структ = Новый Структура( "name,matchedStatuses", "Ошибка", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "broken" );
	структ = Новый Структура( "name,matchedStatuses", "Предупреждение", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "skipped" );
	структ = Новый Структура( "name,matchedStatuses", "Пропущено", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "passed" );
	структ = Новый Структура( "name,matchedStatuses", "Исправлено", массивСтатусов );
	категории.Добавить( структ );
	
<<<<<<< HEAD
	
	ЗаписатьJSON( ЗаписьJSON, категории );
	ЗаписьJSON.Закрыть();

=======
	ЗаписатьФайлJSON( имяФайлаКатегорий, категории);
	
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
КонецПроцедуры

Функция ПолучитьКонтексты( Знач пОписание )
	
	начало = СтрНайти( пОписание, "[" );
	конец  = СтрНайти( пОписание, "]", НаправлениеПоиска.СКонца );
	
	Если начало < конец
		И конец > 0 Тогда
		
		стрКонтексты = Сред( пОписание, начало + 1, конец - начало -1 );
		
		Возврат СтрРазделить( стрКонтексты, "," );
		
	Иначе
		
		Возврат Новый Массив;
		
	КонецЕсли;
	
КонецФункции

Функция ОписаниеФункциональности( Знач пОписание )
	
	начало = СтрНайти( пОписание, "[" );
	
	Если начало > 0 Тогда
		
		описаниеБезКонтекста = Лев( пОписание, начало - 1 );
		
	Иначе
		
		описаниеБезКонтекста = пОписание;
		
	КонецЕсли;
	
	ПозицияКавычки = СтрНайти( описаниеБезКонтекста, """" );
	
	Пока ПозицияКавычки > 0 Цикл
		
		ПозицияЗакрывающейКавычки = СтрНайти( Сред( описаниеБезКонтекста, ПозицияКавычки + 1 ), """" ) + ПозицияКавычки;
		
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		описаниеБезКонтекста = Лев( описаниеБезКонтекста, ПозицияКавычки - 1 ) + "<>" + Сред( описаниеБезКонтекста, ПозицияЗакрывающейКавычки + 1 );
		ПозицияКавычки       = СтрНайти( описаниеБезКонтекста, """" );
		
	КонецЦикла;
	
	ПозицияКавычки = СтрНайти( описаниеБезКонтекста, "'" );
	
	Пока ПозицияКавычки > 0 Цикл
		
		ПозицияЗакрывающейКавычки = СтрНайти( Сред( описаниеБезКонтекста, ПозицияКавычки + 1 ), "'" ) + ПозицияКавычки;
		
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		описаниеБезКонтекста = Лев( описаниеБезКонтекста, ПозицияКавычки - 1 ) + "<>" + Сред( описаниеБезКонтекста, ПозицияЗакрывающейКавычки + 1 );
		ПозицияКавычки       = СтрНайти( описаниеБезКонтекста, "'" );
		
	КонецЦикла;
	
	начало = СтрНайти( пОписание, ":", НаправлениеПоиска.СКонца );
	
	Если начало > 0 Тогда
		
		описаниеБезКонтекста = СокрЛП( Лев( описаниеБезКонтекста, начало - 1 ) );
		
	КонецЕсли;
	
	Возврат СокрЛП( описаниеБезКонтекста );
	
КонецФункции

Функция ПолучитьОписаниеСценарияАллюр2()
	
<<<<<<< HEAD
	GUID                = Новый УникальныйИдентификатор();
	СтруктураРезультата = Новый Структура(); //"uuid, historyId, name, status, parameters, labels, links, attachments");
	СтруктураРезультата.Вставить( "uuid", Строка( GUID ) );
=======
	СтруктураРезультата = Новый Структура();
	СтруктураРезультата.Вставить( "uuid", Строка( Новый УникальныйИдентификатор() ) );
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	СтруктураРезультата.Вставить( "historyId", Неопределено );
	СтруктураРезультата.Вставить( "name", Неопределено );
	СтруктураРезультата.Вставить( "fullName", Неопределено );
	СтруктураРезультата.Вставить( "start", Неопределено );
	СтруктураРезультата.Вставить( "stop", Неопределено );
	СтруктураРезультата.Вставить( "statusDetails", Новый Структура( "known, muted,flaky", Ложь, Ложь, Ложь ) );
	СтруктураРезультата.Вставить( "status", Неопределено );
<<<<<<< HEAD
	СтруктураРезультата.Вставить( "stage", "finished" ); // Внятного описания, зачем это в каждом сценарии нет.
	СтруктураРезультата.Вставить( "steps", Новый Массив() );
	СтруктураРезультата.Вставить( "parameters", Новый Массив() );
	СтруктураРезультата.Вставить( "labels", Новый Массив() );
	СтруктураРезультата.Вставить( "links", Новый Массив() );
	СтруктураРезультата.Вставить( "attachments", Новый Массив() );
=======
	СтруктураРезультата.Вставить( "stage", "finished" );
	СтруктураРезультата.Вставить( "steps", Новый Массив );
	СтруктураРезультата.Вставить( "parameters", Новый Массив );
	СтруктураРезультата.Вставить( "labels", Новый Массив );
	СтруктураРезультата.Вставить( "links", Новый Массив );
	СтруктураРезультата.Вставить( "attachments", Новый Массив );
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82
	СтруктураРезультата.Вставить( "description", Неопределено );
	
	Возврат СтруктураРезультата;
	
КонецФункции

<<<<<<< HEAD
Функция ПутьКФайлуРезультата()
	
	Возврат "D:\validation-result.txt";
	
КонецФункции

Функция ПутьКФайлу_СтарыйРезультат()
	
	Возврат "D:\validation-result_old.txt";
	
КонецФункции

Функция ПутьКФайлу_НовыйРезультат()
	
	Возврат "D:\validation-result_new.txt";
	
КонецФункции

Функция ПапкаСОтчетомАллюр()
	
	Возврат "c:\Program Files (x86)\Jenkins\workspace\Тест создания отчета по проверке\allure-results\";
	
КонецФункции

=======
Процедура ЗаписатьФайлJSON(Знач ИмяФайла, Знач пЗначение)
	
	Запись = Новый ЗаписьТекста;
	Запись.Открыть(ИмяФайла);
	Запись.Записать(ПарсерJSON.ЗаписатьJSON(пЗначение));
	Запись.Закрыть();
	
КонецПроцедуры
>>>>>>> 2ad7dab5f0d3d1c2441bcef71cc1b5e83335ae82

